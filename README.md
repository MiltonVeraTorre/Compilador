# Compilador BabyDuck

Un proyecto de compilador para el lenguaje BabyDuck construido con TypeScript y Chevrotain. Este compilador implementa un lexer y un parser para el lenguaje BabyDuck.

## Descripci√≥n del Proyecto

El compilador BabyDuck es una implementaci√≥n de un compilador para un lenguaje de programaci√≥n sencillo. El proyecto usa los siguientes conceptos:

- An√°lisis l√©xico
- An√°lisis sint√°ctico
- √Årboles de sintaxis
- Manejo de errores l√©xicos y sint√°cticos
- Validaciones sem√°nticas
- Generaci√≥n de c√≥digo intermedio (en desarrollo)

## Instalaci√≥n y Configuraci√≥n

Para instalar y configurar el proyecto:

```bash
# Clonar el repo
git clone https://github.com/MiltonVeraTorre/Compilador.git

# Entrar a la carpeta
cd Compilador

# Instalar dependencias
npm install

# Compilar el proyecto
npm run build

# Ejecutar los tests
npm test

# Ejecutar el ejemplo
npm start
```

## El Lenguaje BabyDuck

BabyDuck es un lenguaje de programaci√≥n chiquito pero funcional, que tiene:

- Declaraci√≥n de variables con tipo
- Funciones con par√°metros
- Estructuras de control (`if`, `while`, etc)
- Operaciones aritm√©ticas y relacionales
- Impresi√≥n de valores con `print`

### Gram√°tica B√°sica

La gram√°tica de BabyDuck sigue esta estructura:

```
<program> ::= program Id ';' <varsOpt> <funcsOpt> main <body> end
<varsOpt> ::= var <varDecl> | Œµ
<varDecl> ::= <idList> ':' <type> ';' <varDecl> | Œµ
<funcsOpt> ::= <func> <funcsOpt> | Œµ
<func> ::= void Id '(' <paramList> ')' '[' <varsOpt> <body> ']' ';'
<body> ::= '{' <stmtList> '}'
```

### Ejemplos de Programas

#### Ejemplo B√°sico:

```babyduck
program ejemplo;
var
  x: int;
  y: int;

main {
  x = 5;
  y = 10;
  print(x + y);
}
end
```

#### Ejemplo con Condicionales:

```babyduck
program condicionales;
var
  edad: int;

main {
  edad = 18;

  if (edad >= 18) {
    print("Eres mayor de edad");
  } else {
    print("Eres menor de edad");
  };
}
end
```

#### Ejemplo con Ciclos:

```babyduck
program ciclos;
var
  contador: int;

main {
  contador = 5;

  while (contador > 0) do {
    print(contador);
    contador = contador - 1;
  };
}
end
```

#### Ejemplo con Funciones:

```babyduck
program funciones;
var
  a: int;
  b: int;

void suma(x: int, y: int) [
  var
    resultado: int;
  {
    resultado = x + y;
    print(resultado);
  }
];

main {
  a = 10;
  b = 20;
  suma(a, b);
}
end
```

## Estructura del Proyecto

```
src/
  lexer/
    lexer.ts       # Analizador l√©xico
    tokens.ts      # Definici√≥n de tokens del lenguaje
  parser/
    parser.ts      # Analizador sint√°ctico
    grammar.ts     # Gram√°tica BabyDuck
    cst-types.ts   # Tipos para el √°rbol de sintaxis
  semantic/
    semantic-analyzer.ts    # Analizador sem√°ntico
    function-directory.ts   # Directorio de funciones
    variable-table.ts       # Tabla de variables
    semantic-cube.ts        # Cubo sem√°ntico para validar tipos
    index.ts                # Exportaciones de componentes sem√°nticos
  index.ts         # Entrada principal del compilador
  index.test.ts    # Tests b√°sicos con Jest
  semantic.test.ts # Tests sem√°nticos
  example.ts       # Ejemplo de uso
```

## Flujo de Compilaci√≥n

1. **An√°lisis L√©xico**: El c√≥digo fuente se convierte en tokens usando Chevrotain.
   - Se identifican palabras clave, identificadores, literales, etc.
   - Se detectan errores l√©xicos como caracteres inv√°lidos.

2. **An√°lisis Sint√°ctico**: Se validan las reglas gramaticales.
   - Se construye un √°rbol de sintaxis concreto (CST).
   - Se detectan errores sint√°cticos como estructura incorrecta.

3. **An√°lisis Sem√°ntico**: Se checa que el programa tenga sentido l√≥gico.
   - Se validan tipos en expresiones y asignaciones.
   - Se verifica que las variables est√©n declaradas.
   - Se comprueban par√°metros en llamadas a funciones.
   - Se detectan errores como variables duplicadas.

4. **Generaci√≥n de c√≥digo** (en desarrollo):
   - Se asignan direcciones de memoria virtual.
   - Se generar√° c√≥digo intermedio para ejecuci√≥n.

## C√≥mo Ejecutar Tests

Para ejecutar los tests del compilador:

```bash
# Ejecutar todos los tests
npm test

# Ejecutar solo tests del lexer/parser
npx jest index.test.ts

# Ejecutar solo tests sem√°nticos
npx jest semantic.test.ts
```

Los tests verifican tanto casos correctos como detecci√≥n de errores.

---

# Documentaci√≥n de Componentes Sem√°nticos - BabyDuck

## √çndice

1. [Introducci√≥n](#introducci√≥n)
2. [Cubo Sem√°ntico](#cubo-sem√°ntico)
3. [Directorio de Funciones](#directorio-de-funciones)
4. [Tabla de Variables](#tabla-de-variables)
5. [Analizador Sem√°ntico](#analizador-sem√°ntico)
6. [Puntos Neur√°lgicos](#puntos-neur√°lgicos)
7. [Validaciones Sem√°nticas](#validaciones-sem√°nticas)
8. [Manejo de Errores](#manejo-de-errores)
9. [Asignaci√≥n de Memoria](#asignaci√≥n-de-memoria)
10. [Integraci√≥n con el Compilador](#integraci√≥n-con-el-compilador)

## Introducci√≥n

Aqu√≠ explico los componentes sem√°nticos que hice para BabyDuck, como el cubo sem√°ntico, el directorio de funciones, la tabla de variables y el analizador sem√°ntico. Todos estos se usan para validar que el c√≥digo tenga sentido, o sea que no solo est√© bien escrito sino que haga lo que se supone.

El an√°lisis sem√°ntico valida cosas como:

- Que las variables est√©n declaradas antes de usarse
- Que no haya nombres repetidos
- Que los tipos concuerden
- Que las funciones se llamen bien (con sus par√°metros y todo eso)

---

## Cubo Sem√°ntico

El cubo sem√°ntico es como una tabla de compatibilidad de tipos. Yo lo hice como un `Map<string, DataType>` donde la clave es algo como `int+float` y el valor es el tipo resultante (`float` en ese caso).

### Tipos Soportados

```ts
enum DataType {
  INT = 'int',
  FLOAT = 'float',
  STRING = 'string',
  VOID = 'void',
  ERROR = 'error'
}
```

### Operadores Soportados

```ts
enum Operator {
  PLUS = '+',
  MINUS = '-',
  MULTIPLY = '*',
  DIVIDE = '/',
  GREATER_THAN = '>',
  LESS_THAN = '<',
  NOT_EQUALS = '!=',
  ASSIGN = '='
}
```

### Reglas Ejemplo

- `int + int = int`
- `int / int = float`
- `float + int = float`
- `int = float` ‚ùå
- `float = int` ‚úÖ

Lo hice as√≠ porque usar `Map` es muy r√°pido y no necesitas hacer cientos de ifs para checar los tipos.

---

## Directorio de Funciones

Este directorio guarda todas las funciones con su nombre, tipo, par√°metros y variables locales. Se implement√≥ con otro `Map<string, Function>`.

```ts
interface Function {
  name: string;
  type: DataType;
  parameters: Variable[];
  variableTable: VariableTable;
  startAddress?: number;
}
```

Aqu√≠ puedes agregar funciones, buscar funciones, agregar par√°metros, etc.

---

## Tabla de Variables

Cada funci√≥n tiene su propia tabla de variables. Es un `Map<string, Variable>` y as√≠ no se repiten nombres dentro del mismo scope.

```ts
interface Variable {
  name: string;
  type: DataType;
  address?: number;
  isParameter?: boolean;
}
```

---

## Analizador Sem√°ntico

Este analizador revisa el CST y checa todo: tipos, existencia de variables, par√°metros, etc. Lo hice para que trabaje en paralelo con el parser.

Tiene una lista de errores (`SemanticError[]`) y m√©todos como:

- `processVars()`
- `processAssign()`
- `processFunc()`
- `processExpression()`

```ts
interface SemanticError {
  message: string;
  line?: number;
  column?: number;
  type: 'error' | 'warning';
}
```

---

## Puntos Neur√°lgicos

Estos son los puntos clave donde se hacen validaciones:

- Declaraci√≥n de variables y funciones
- Uso correcto de par√°metros
- Tipos en expresiones y asignaciones
- Llamadas a funciones bien formadas

Ejemplo: si usas `x = "hola" + 5`, eso lanza un error porque `string + int` no tiene sentido.

---

## Validaciones Sem√°nticas

Aqu√≠ unas validaciones que implement√© con ejemplos:

1. **Variable doblemente declarada**:

```babyduck
var
  x: int;
  x: float;  // ‚ùå Error
```

2. **Funci√≥n no declarada**:

```babyduck
main {
  resultado = sumar(5, 2);  // ‚ùå Error
}
```

3. **Tipos incompatibles en asignaci√≥n**:

```babyduck
x: int;
y: float;

x = y; // ‚ùå Error
```

4. **Argumentos incorrectos**:

```babyduck
function sumar(a, b: int): int;

main {
  x = sumar(5); // ‚ùå Falta un argumento
}
```

---

## Manejo de Errores

El analizador junta todos los errores sem√°nticos y te los muestra con mensaje, l√≠nea, y tipo de error. Ejemplos:

- `Variable no declarada: x`
- `Operaci√≥n inv√°lida: int + string`
- `N√∫mero incorrecto de argumentos`

Esto ayuda a debuggear tu c√≥digo m√°s f√°cil.

---

## Asignaci√≥n de Memoria

Cada variable o funci√≥n tiene un campo `address`. Esto lo uso para que al generar c√≥digo sepamos en qu√© parte de memoria virtual se guarda.

```ts
interface Variable {
  name: string;
  address?: number;
}
```

---

## Integraci√≥n con el Compilador

Los componentes sem√°nticos se conectan con el parser y trabajan directamente con el CST generado. El proceso es as√≠:

1. Lexer crea los tokens
2. Parser construye el CST
3. Analizador sem√°ntico valida
4. Se genera el c√≥digo si no hay errores

Al hacerlo todo en un mismo flujo, el compilador es m√°s r√°pido y encuentra errores m√°s pronto.

---

# Estado Actual y Trabajo Futuro

## Componentes Implementados
- ‚úÖ Analizador L√©xico completo
- ‚úÖ Analizador Sint√°ctico completo
- ‚úÖ Analizador Sem√°ntico funcional
- ‚úÖ Cubo Sem√°ntico para validaci√≥n de tipos
- ‚úÖ Directorio de Funciones y Tabla de Variables
- ‚úÖ Detecci√≥n de errores l√©xicos, sint√°cticos y sem√°nticos

## En Desarrollo
- üîÑ Asignaci√≥n de memoria virtual
- üîÑ Generaci√≥n de c√≥digo intermedio

